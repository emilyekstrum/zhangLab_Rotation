---
title: "Human Brain (DLPFC) 10x EDA & Seurat"
author: "Emily Ekstrum"
date: ""
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: cosmo
params:
  # gene expression
  h5_path: "/Users/emilyekstrum/Desktop/zhangLab/data/DLPFC_Data/Sample151673/151673_filtered_feature_bc_matrix.h5"

  # spatial coordinates
  spatial_csv: "/Users/emilyekstrum/Desktop/zhangLab/data/DLPFC_Data/Sample151673/DLPFC_spatial_3639cells_2cols.csv"

  # manual annotations
  annotation_csv: "/Users/emilyekstrum/Desktop/zhangLab/data/DLPFC_Data/Sample151673/Manual_annotation_3639cells.csv"

  # for seurat object
  assay_name: "RNA"
  min_cells: 3
  min_features: 200

  # filtering params
  filter: true
  nFeature_low: 200
  nFeature_high: 7500
  nCount_high: 60000
  mt_prefix: "^(mt-|MT-)"
  percent_mt_high: 20

  # dim reduction params
  n_pcs: 30
  clustering_resolution: 0.5
  seed: 123
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 8,
  fig.height = 5
)
set.seed(params$seed)

`%||%` <- function(a, b) if (!is.null(a)) a else b
```

# Overview

This report reproduces the same Seurat pipeline you ran for the mouse brain data, but for the **human brain (DLPFC) dataset** stored as a 10x `.h5` matrix:

1. Load 10x counts (`Read10X_h5`)
2. Optionally merge spatial coordinates and manual annotations into `meta.data`
3. EDA/QC: library size, detected genes, mitochondrial fraction
4. Optional filtering
<!-- 5. Standard Seurat workflow: Normalize → HVFs → Scale → PCA → Neighbors → Clusters → UMAP -->
6. Spatial visualization using coordinate scatter plots (works even without histology images)

**Inputs**
- Counts: `r params$h5_path`
- Spatial coords (optional): `r params$spatial_csv`
- Manual annotations (optional): `r params$annotation_csv`

# Packages

```{r packages}
pkgs <- c("Seurat","Matrix","ggplot2","dplyr","tibble","patchwork","readr", "hdf5r")
to_install <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
if (length(to_install) > 0) install.packages(to_install, repos = "https://cloud.r-project.org")
lapply(pkgs, library, character.only = TRUE)
```

# Load counts from 10x H5

```{r load-h5}
h5_path <- params$h5_path
stopifnot(file.exists(h5_path))

counts <- Read10X_h5(h5_path)

# Read10X_h5 may return a matrix OR a named list of matrices (e.g., "Gene Expression")
if (is.list(counts)) {
  message("Read10X_h5 returned a list with names: ", paste(names(counts), collapse = ", "))
  # Prefer common key names
  key <- intersect(names(counts), c("Gene Expression","RNA","gene_expression","GeneExpression"))
  if (length(key) == 0) key <- names(counts)[1]
  counts <- counts[[key[1]]]
}

stopifnot(inherits(counts, c("dgCMatrix","matrix")))
dim(counts)
```

# Load optional metadata (spatial coords + manual annotations)

This section tries to merge metadata by cell barcode when possible. If no explicit barcode column is found, it falls back to matching by row order only when the row count matches the number of cells.

```{r load-meta}
load_csv_if_exists <- function(path) {
  if (is.null(path) || path == "" || is.na(path) || !file.exists(path)) return(NULL)
  df <- readr::read_csv(path, show_col_types = FALSE)
  as.data.frame(df)
}

spatial_df <- load_csv_if_exists(params$spatial_csv)
annot_df   <- load_csv_if_exists(params$annotation_csv)

if (!is.null(spatial_df)) {
  message("Loaded spatial CSV with dim: ", paste(dim(spatial_df), collapse=" x "))
  print(head(spatial_df, 3))
} else {
  message("No spatial CSV loaded (file missing or params$spatial_csv is blank).")
}

if (!is.null(annot_df)) {
  message("Loaded annotation CSV with dim: ", paste(dim(annot_df), collapse=" x "))
  print(head(annot_df, 3))
} else {
  message("No annotation CSV loaded (file missing or params$annotation_csv is blank).")
}
```

## Merge helper

```{r merge-helper}
guess_barcode_col <- function(df) {
  if (is.null(df)) return(NULL)
  nms <- tolower(names(df))
  candidates <- c("barcode","barcodes","cell","cell_id","cellid","spot","spot_id","id")
  hit <- candidates[candidates %in% nms]
  if (length(hit) > 0) return(names(df)[match(hit[1], nms)])
  NULL
}

merge_meta <- function(meta, df, cells) {
  if (is.null(df)) return(meta)

  bc_col <- guess_barcode_col(df)

  if (!is.null(bc_col)) {
    df[[bc_col]] <- as.character(df[[bc_col]])
    rownames(df) <- df[[bc_col]]
    df[[bc_col]] <- NULL
    df2 <- df[intersect(rownames(df), cells), , drop = FALSE]
    meta[rownames(df2), names(df2)] <- df2
    return(meta)
  }

  if (nrow(df) == length(cells)) {
    rownames(df) <- cells
    meta[cells, names(df)] <- df
    return(meta)
  }

  warning("Could not merge metadata: no obvious barcode column and row count did not match cell count.")
  return(meta)
}
```

# Create Seurat object

```{r create-seurat}
cells <- colnames(counts)
meta <- data.frame(row.names = cells)

meta <- merge_meta(meta, spatial_df, cells)
meta <- merge_meta(meta, annot_df,   cells)

seu <- CreateSeuratObject(
  counts = counts,
  assay = params$assay_name,
  min.cells = params$min_cells,
  min.features = params$min_features,
  meta.data = meta
)

# add mitochondrial percentage
mt_features <- grep(params$mt_prefix, rownames(seu), value = TRUE)

if (length(mt_features) > 0) {
  mouse_seurat[["percent.mt"]] <- PercentageFeatureSet(seu, features = mt_features)
} else {
  warning(paste0(
    "No mitochondrial genes matched params$mt_prefix = '", params$mt_prefix,
    "'. percent.mt will not be computed."
  ))
}

seu
```

# EDA and QC

```{r qc-basic}
features_to_plot <- c("nFeature_RNA", "nCount_RNA", "percent.mt")
VlnPlot(seu, features = features_to_plot, ncol = length(features_to_plot), pt.size = 0.1)
```


```{r qc-scatter}
p_a <- FeatureScatter(seu, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
if ("percent.mt" %in% colnames(seu@meta.data)) {
  p_b <- FeatureScatter(seu, feature1 = "nCount_RNA", feature2 = "percent.mt")
  p_a + p_b
} else {
  p_a
}
```

# filtering

```{r}
if (isTRUE(params$filter)) {
  message("Filtering enabled with thresholds:")
  print(list(
    nFeature_low = params$nFeature_low,
    nFeature_high = params$nFeature_high,
    nCount_high = params$nCount_high,
    percent_mt_high = params$percent_mt_high
  ))

expr <- seu@meta.data$nFeature_RNA >= params$nFeature_low &
        seu@meta.data$nFeature_RNA <= params$nFeature_high &
        seu@meta.data$nCount_RNA <= params$nCount_high &
        seu@meta.data$percent.mt <= params$percent_mt_high

  if ("percent.mt" %in% colnames(seu@meta.data)) {
    expr <- expr & (seu@meta.data$percent.mt <= params$percent_mt_high)
  }

  seu <- subset(seu, cells = rownames(seu@meta.data)[expr])
}

# Check for NA/NaN/Inf values in count matrix
counts_mat <- GetAssayData(seu, assay = "RNA", layer = "counts")

bad <- is.na(counts_mat) | is.infinite(counts_mat)
if (any(bad)) {
  warning("Found NA/Inf in count matrix. Replacing with 0.")
  counts_mat[bad] <- 0
  seu <- SetAssayData(seu, assay = "RNA", layer = "counts", new.data = counts_mat)
}


# Remove spots with zero total counts (can cause log_umi issues)
zero_count_spots <- which(seu$nCount_RNA == 0)
if (length(zero_count_spots) > 0) {
  warning(paste("Removing", length(zero_count_spots), "spots with zero total counts"))
  cells_to_keep <- setdiff(colnames(seu), names(zero_count_spots))
  seu <- subset(seu, cells = cells_to_keep)
}

# Optional: Filter out low quality spots (uncomment if needed)
# seurat_obj <- subset(seurat_obj, subset = nFeature_RNA > 200 & nFeature_RNA < 8000 & percent.mt < 20)

# Print summary statistics to verify data quality
cat("Data quality summary:\n")
cat("Number of spots:", ncol(seu), "\n")
cat("Number of genes:", nrow(seu), "\n")
cat("nCount_RNA range:", range(seu$nCount_RNA), "\n")
cat("nFeature_RNA range:", range(seu$nFeature_RNA), "\n")
cat("Percent MT range:", range(seu$percent.mt), "\n")

# variance stabilizing transformation using SCTransform
seu_sct <- SCTransform(seu,
                          vst.flavor = "v2",
                          variable.features.n = 10000,
                          vars.to.regress = c("percent.mt"),
                          return.only.var.genes = FALSE,
                          verbose = FALSE)

seu_sct
```


```{r}
# recompute nCount_RNA from counts matrix
counts_mat <- GetAssayData(seu_sct, assay = "RNA", layer = "counts")
seu_sct$nCount_RNA <- Matrix::colSums(counts_mat)
summary(seu_sct$nCount_RNA)
```

```{r}
# recompute nCount_SCT from SCT counts matrix
sct_mat <- GetAssayData(seu_sct, assay = "SCT", layer = "counts")
seu_sct$nCount_SCT <- Matrix::colSums(sct_mat)
summary(mouse_seurat_sct$nCount_SCT)

```


# Spatial visualization (coordinate scatter plots)

This does **not** require histology images. It just uses whatever coordinate columns exist in `meta.data`.

## Detect coordinate columns

```{r coords-detect}
meta_cols <- colnames(seu_sct@meta.data)
coord_candidates <- list(
  x = c("x","imagecol","col","pxl_col_in_fullres","array_col"),
  y = c("y","imagerow","row","pxl_row_in_fullres","array_row")
)

find_first_present <- function(cands, cols) {
  hit <- cands[cands %in% cols]
  if (length(hit) == 0) return(NULL)
  hit[1]
}

xcol <- find_first_present(coord_candidates$x, meta_cols)
ycol <- find_first_present(coord_candidates$y, meta_cols)

list(xcol = xcol, ycol = ycol)
```

## Plot clusters on tissue coordinates

```{r spatial-clusters}
if (!is.null(xcol) && !is.null(ycol)) {
  df <- data.frame(seu_sct@meta.data, cluster = Idents(seu_sct))
  ggplot(df, aes(x = .data[[xcol]], y = .data[[ycol]], color = cluster)) +
    geom_point(size = 0.8) +
    coord_fixed() +
    scale_y_reverse() +
    theme_classic() +
    labs(title = "Clusters in tissue coordinates", x = xcol, y = ycol)
} else {
  cat("No recognizable coordinate columns found in meta.data.\\n")
  cat("Available meta.data columns include:\\n")
  print(head(colnames(seu_sct@meta.data), 30))
}
```

## Plot a marker gene on tissue coordinates

```{r spatial-gene}
if (!is.null(xcol) && !is.null(ycol)) {
  gene <- "MBP"  # change 
  if (gene %in% rownames(seu_sct)) {
    df <- data.frame(seu_sct@meta.data, expr = FetchData(seu_sct, vars = gene)[,1])
    ggplot(df, aes(x = .data[[xcol]], y = .data[[ycol]], color = expr)) +
      geom_point(size = 0.8) +
      coord_fixed() +
      scale_y_reverse() +
      theme_classic() +
      labs(title = paste(gene, "expression in tissue coordinates"), x = xcol, y = ycol)
  } else {
    cat("Gene ", gene, " not found. Try another marker (e.g., SNAP25, AQP4, P2RY12, GFAP, MOBP).\\n")
  }
}
```

# dim reduction
```{r seurat-workflow}
# make SCT the default assay for downstream PCA/UMAP
DefaultAssay(seu_sct) <- "SCT"
seu_PCA <- RunPCA(seu_sct, features = VariableFeatures(seu_sct))
```


```{r}
#plot PCA 
ElbowPlot(seu_PCA)

DimPlot(
  seu_PCA,
  reduction = "pca",
  pt.size = 0.6
) + ggtitle("PCA of spatial transcriptomics spots")
```


```{r}
#color PCA by genes & counts
FeaturePlot(seu_PCA, reduction = "pca", features = "nFeature_RNA")
FeaturePlot(seu_PCA, reduction = "pca", features = "nCount_RNA")
```


```{r}
# color PCA by spatial coordinates
FeaturePlot(seu_PCA, reduction = "pca", features = "x")
FeaturePlot(seu_PCA, reduction = "pca", features = "y")

```


```{r}
# genes contributing to PCs
VizDimLoadings(seu_PCA, dims = 1:2, reduction = "pca")
```


```{r}
# top genes per PC
DimHeatmap(seu_PCA, dims = 1:6, cells = 500, balanced = TRUE)

```

```{r umap-cluster}
seu_PCA <- FindNeighbors(seu_PCA, dims = 1:30)
seu_PCA <- FindClusters(seu_PCA, resolution = params$clustering_resolution)
seu_UMAP <- RunUMAP(seu_PCA, dims = 1:30)

DimPlot(seu_UMAP, reduction = "umap", label = TRUE) + NoLegend()
```

# Save outputs

```{r save}
out_dir <- "outputs_human"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

saveRDS(seu, file.path(out_dir, "human_dlpfc_seurat.rds"))

p_umap <- DimPlot(seu, reduction = "umap", label = TRUE) + NoLegend()
ggsave(filename = file.path(out_dir, "umap_clusters.png"), plot = p_umap, width = 7, height = 5, dpi = 300)

cat("Saved outputs to: ", out_dir, "\\n")
```

```{r session-info}
sessionInfo()
```

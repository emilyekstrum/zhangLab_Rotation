---
title: "R Notebook"
output: html_notebook
---

Use CellChatDB's LR databese as reference.
Take 10x Visium mousebrain ST data as an example.

```{r}
#install.packages("languageserver")
#install.packages("BiocManager")
BiocManager::install("glmGamPoi")
```

```{r}
library(Seurat)
library(CellChat)
library(patchwork)
library(dplyr)

```

```{r}
# take 10x mousebrain ST data as an example
exp_count_meta <-readRDS("/Users/emilyekstrum/Desktop/zhangLab/data/MouseBrain_Data/10x_mousebrain_exp_count_meta.rds")
```

```{r}
cell_loc <- exp_count_meta[, c(1:2)] # spot by (x,y)
exp <- exp_count_meta[, 3:31056] # row = spot col = gene
exp_count <- t(exp) # gene by cell -> seurat input

head(exp_count)
```

```{r}
# Create Seurat object
seurat_obj <- CreateSeuratObject(counts = exp_count, project = "SpatialData")

# Add spatial coordinates to meta data
seurat_obj@meta.data$x <- cell_loc$x
seurat_obj@meta.data$y <- cell_loc$y
```

```{r}
# Create spatial coordinates data frame
spatial_coords <- data.frame(
  rownames = rownames(cell_loc),
  imagerow = cell_loc$y,
  imagecol = cell_loc$x
)
rownames(spatial_coords) <- spatial_coords$rownames
```

```{r}
# Add pseudo spatial coordinates to Seurat object
DefaultAssay(seurat_obj) <- "RNA"
seurat_obj@images[["pseudo"]] <- new(
  Class = "SlideSeq",
  coordinates = spatial_coords
)
```

```{r}
# Data validation and cleaning before SCTransform
# Check for and handle problematic values in count data

# Check for NA/NaN/Inf values in count matrix
if (any(is.na(seurat_obj@assays$RNA@counts)) || 
    any(is.infinite(seurat_obj@assays$RNA@counts))) {
  warning("Found NA/NaN/Inf values in count matrix. Replacing with 0.")
  seurat_obj@assays$RNA@counts[is.na(seurat_obj@assays$RNA@counts)] <- 0
  seurat_obj@assays$RNA@counts[is.infinite(seurat_obj@assays$RNA@counts)] <- 0
}

# Add quality control metrics before SCTransform
# Calculate mitochondrial gene percentage (adjust pattern for mouse genes)
seurat_obj[["percent.mt"]] <- PercentageFeatureSet(seurat_obj, pattern = "^mt-")

# Calculate ribosomal gene percentage 
seurat_obj[["percent.ribo"]] <- PercentageFeatureSet(seurat_obj, pattern = "^Rp[sl]")

# Add nCount and nFeature if not already present
seurat_obj[["nCount_RNA"]] <- Matrix::colSums(seurat_obj@assays$RNA@counts)
seurat_obj[["nFeature_RNA"]] <- Matrix::colSums(seurat_obj@assays$RNA@counts > 0)

# Check for and handle problematic values in metadata
metadata_cols <- c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo")
for (col in metadata_cols) {
  if (any(is.na(seurat_obj@meta.data[[col]]) | is.infinite(seurat_obj@meta.data[[col]]))) {
    warning(paste("Found NA/Inf values in", col, ". Replacing with median values."))
    median_val <- median(seurat_obj@meta.data[[col]], na.rm = TRUE)
    seurat_obj@meta.data[[col]][is.na(seurat_obj@meta.data[[col]]) | 
                                is.infinite(seurat_obj@meta.data[[col]])] <- median_val
  }
}

# Remove spots with zero total counts (can cause log_umi issues)
zero_count_spots <- which(seurat_obj$nCount_RNA == 0)
if (length(zero_count_spots) > 0) {
  warning(paste("Removing", length(zero_count_spots), "spots with zero total counts"))
  cells_to_keep <- setdiff(colnames(seurat_obj), names(zero_count_spots))
  seurat_obj <- subset(seurat_obj, cells = cells_to_keep)
}

# Optional: Filter out low quality spots (uncomment if needed)
# seurat_obj <- subset(seurat_obj, subset = nFeature_RNA > 200 & nFeature_RNA < 8000 & percent.mt < 20)

# Print summary statistics to verify data quality
cat("Data quality summary:\n")
cat("Number of spots:", ncol(seurat_obj), "\n")
cat("Number of genes:", nrow(seurat_obj), "\n")
cat("nCount_RNA range:", range(seurat_obj$nCount_RNA), "\n")
cat("nFeature_RNA range:", range(seurat_obj$nFeature_RNA), "\n")
cat("Percent MT range:", range(seurat_obj$percent.mt), "\n")

# variance stabilizing transformation using SCTransform
seurat_obj <- SCTransform(seurat_obj,
                          vst.flavor = "v2",
                          variable.features.n = 10000,
                          vars.to.regress = c("percent.mt"),
                          return.only.var.genes = FALSE,
                          verbose = FALSE)

```

```{r}
seurat_obj$nCount_RNA <- Matrix::colSums(seurat_obj@assays$RNA@counts)
summary(seurat_obj$nCount_RNA)

```

```{r}

CellChatDB <- CellChatDB.mouse
showDatabaseCategory(CellChatDB)
```


```{r}
# LR table
db_interactions <- CellChatDB$interaction
```

```{r}
# use only a subset, e.g., secreted signaling
CellChatDB.use <- subsetDB(CellChatDB, search = "Secreted Signaling")
```

```{r}
dplyr::glimpse(CellChatDB$interaction)
```

```{r}
# use all CellChatDB except for "Non-protein Signaling" for cell-cell communication analysis
CellChatDB.use <- subsetDB(CellChatDB)

```

```{r}
dplyr::glimpse(CellChatDB.use$interaction)

```

```{r}
# LR table
# use all CellChatDB except for "Non-protein Signaling" for cell-cell communication analysis
db_interactions_use <- CellChatDB.use$interaction
```

Get LR definitions that the Visium mouse brain can support
```{r}
# genes present in the expression matrix
genes_in_data <- colnames(exp)

# Keep LR entries whose all ligand and receptor subunits exist in the data.

lr_present <- db_interactions_use |>
  rowwise() |>
  filter(all(unlist(strsplit(ligand, "\\|")) %in% genes_in_data) &
           all(unlist(strsplit(receptor, "\\|")) %in% genes_in_data)) |>
  ungroup()
```


### Find spatial variable genes
#### SCT and find HVGs
```{r}
stopifnot(is.matrix(Y_sim) || inherits(Y_sim, "dgCMatrix"))
if (!all(Y_sim == round(Y_sim))) {
  warning("Counts contain non-integers; SCTransform assumes UMI counts.")
}

# Build Seurat object
obj <- CreateSeuratObject(counts = Y_sim)


obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")

# ---- SCTransform ----
# vst.flavor = "v2"
obj <- SCTransform(
  obj,
  vst.flavor = "v2",
  variable.features.n = 3000,
  vars.to.regress = "percent.mt",
  verbose = FALSE
)
```

```{r}
# ---- Get HVGs ----
hvg <- VariableFeatures(obj, assay = "SCT")
length(hvg)
head(hvg, 20)
```


### Find spatially variable genes using nnSVG

```{r}
#install.packages("BiocManager")
BiocManager::install("BiocParallel")
#install.packages("BRISC")
```

```{r message=FALSE, warning=FALSE}
library(BiocParallel)
library(BRISC)
```

```{r}
count_sim <- Y_sim[hvg,]
```

```{r}
exp_count <- t(exp)
start_time <- Sys.time()
svgs <- nnSVG(input = exp, spatial_coords = cell_loc, n_threads = 3)
end_time <- Sys.time()
time_nnsvg <- end_time - start_time
time_nnsvg
```

```{r}
write.csv(svgs, "/Users/nanxi/Documents/ZhangLab/Spatial_transcriptomics/Spatial_clusters/Output/SIm3_151673/srt_sim_151673_nnsvg.csv")
```

```{r}
svgs <- read.csv("/Users/nanxi/Documents/ZhangLab/Spatial_transcriptomics/Spatial_clusters/Output/SIm3_151673/srt_sim_151673_nnsvg.csv")
```

```{r}
plot(sort(-log(svgs[,"padj"])))
table(svgs[,"padj"] < 0.1) # 2454 genes
```

```{r}
svgs <- as.data.frame(svgs)

# Subset the genes where padj < 0.05
auto_genes_list <- svgs %>%
  filter(padj < 0.1) %>%
  rownames()

count_sim <- count_sim[auto_genes_list,] # 2454 x 3611
```


```{r}
#Only needs BioCParallel and BRISC

nnSVG <- function(input, spatial_coords = NULL, X = NULL, 
                  assay_name = "logcounts", 
                  n_neighbors = 10, order = "AMMD", 
                  n_threads = 1, BPPARAM = NULL, 
                  verbose = FALSE) {
  
  if (is(input, "SpatialExperiment")) {
    spe <- input
    stopifnot(assay_name %in% assayNames(spe))
    # check for rows or columns of all zero counts
    if ("counts" %in% assayNames(spe)) {
      if (sum(rowSums(counts(spe)) == 0) > 0 | sum(colSums(counts(spe)) == 0) > 0) {
        warning("Rows (genes) and/or columns (spots) containing all zero counts ", 
                "have been found. Please see examples in tutorial for code to ", 
                "filter out zeros and/or low-expressed genes to avoid errors.")
      }
    }
  }

  if (!is.null(X)) {
    stopifnot(nrow(X) == ncol(input))
  }

  if (is.null(BPPARAM)) {
    BPPARAM <- MulticoreParam(workers = n_threads)
  }

  # -----------------------
  # run BRISC for each gene
  # -----------------------

  if (is(input, "MulticoreParam")) {
    y <- assays(spe)[[assay_name]]
    coords <- spatialCoords(spe)
  } else {
    y <- input
    coords <- spatial_coords
    row_names <- rownames(input)
  }

  # scale coordinates proportionally
  range_all <- max(apply(coords, 2, function(col) diff(range(col))))
  coords <- apply(coords, 2, function(col) (col - min(col)) / range_all)

  # calculate ordering of coordinates
  order_brisc <- BRISC_order(coords, order = order, verbose = verbose)

  # calculate nearest neighbors for nearest neighbors gaussian process (NNGP) model
  nn_brisc <- BRISC_neighbor(coords, n.neighbors = n_neighbors, n_omp = 1, 
                             search.type = "tree", ordering = order_brisc, 
                             verbose = verbose)
  
  # run BRISC using parallelization
  ix <- seq_len(nrow(y))
  out_brisc <- bplapply(ix, function(i) {
    # fit model (intercept-only model if x is NULL)
    y_i <- y[i, ]
    suppressWarnings({
      runtime <- system.time({
        out_i <- BRISC_estimation(coords = coords, y = y_i, x = X, 
                                  cov.model = "exponential", 
                                  ordering = order_brisc, neighbor = nn_brisc, 
                                  verbose = verbose)
      })
    })
    res_i <- c(
      out_i$Theta,
      loglik = out_i$log_likelihood,
      runtime = runtime[["elapsed"]]
    )
    res_i
  }, BPPARAM = BPPARAM)

  # collapse output list into matrix
  mat_brisc <- do.call("rbind", out_brisc)

  # --------------------
  # calculate statistics
  # --------------------

  lc <- input
  # mean logcounts
  mat_brisc <- cbind(
    mat_brisc,
    mean = rowMeans(lc)
  )
  # variance of logcounts
  mat_brisc <- cbind(
    mat_brisc,
    var = rowVars(as.matrix(lc))
  )
  # spatial coefficient of variation
  mat_brisc <- cbind(
    mat_brisc,
    spcov = sqrt(mat_brisc[, "sigma.sq"]) / mat_brisc[, "mean"]
  )

  # proportion of spatial variance out of total variance
  mat_brisc <- cbind(
    mat_brisc,
    prop_sv = mat_brisc[, "sigma.sq"] / (mat_brisc[, "sigma.sq"] + mat_brisc[, "tau.sq"])
  )

  # ------------------------------------------
  # likelihood ratio (LR) statistics and tests
  # ------------------------------------------

  if (is(input, "SpatialExperiment")) {
    nrows <- nrow(spe)
    ncols <- ncol(spe)
  } else {
    nrows <- nrow(input)
    ncols <- ncol(input)
  }
  
  # calculate log likelihoods for nonspatial models
  # uses linear model (MLE)
  loglik_lm <- vapply(seq_len(nrows), function(i) {
    y_i <- y[i, ]
    if (is.null(X)) {
      X <- rep(1, ncols)
    }
    # model formula without intercept to enable weighted model
    as.numeric(logLik(lm(y_i ~ X - 1)))
  }, numeric(1))
  
  mat_brisc <- cbind(
    mat_brisc, 
    loglik_lm = loglik_lm
  )
  
  # calculate LR statistics and tests (Wilks' theorem, asymptotic chi-square
  # with 2 degrees of freedom)
  
  LR_stat <- -2 * (mat_brisc[, "loglik_lm"] - mat_brisc[, "loglik"])
  
  pval <- 1 - pchisq(LR_stat, df = 2)
  padj <- p.adjust(pval, method = "BH")
  
  # rank SVGs according to LR statistics
  LR_rank <- rank(-1 * LR_stat)
  
  mat_brisc <- cbind(
    mat_brisc, 
    LR_stat = LR_stat, 
    rank = LR_rank, 
    pval = pval, 
    padj = padj
  )

  # --------------
  # return outputs
  # --------------

  if (is(input, "SpatialExperiment")) {
    # return in rowData of spe object
    stopifnot(nrow(spe) == nrow(mat_brisc))
    rowData(spe) <- cbind(rowData(spe), mat_brisc)
    spe
  } else {
    # return as numeric matrix
    stopifnot(nrow(input) == nrow(mat_brisc))
    rownames(mat_brisc) <- row_names
    mat_brisc
  }
}
```


```{r} 

```



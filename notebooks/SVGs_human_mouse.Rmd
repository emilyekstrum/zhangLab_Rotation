---
title: "SVG Selection in Human and Mouse Data"
author: "Emily Ekstrum"
date: "1/8/26"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: "cosmo"
    df_print: paged
    
params:
  mouse_rds_path: "/Users/emilyekstrum/repos/zhangLab_Rotation/data/processed/mousebrain_seurat.rds"
  human_rds_path: "/Users/emilyekstrum/repos/zhangLab_Rotation/data/processed/humanbrain_seurat.rds"
  seed: 123
---

# file setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 8,
  fig.height = 5
)
set.seed(params$seed)
```

# SVG Selection in Mouse Brain Spatial Transcriptomics Data

> **Input**: `r params$mouse_rds_path`

# load in packages

```{r packages}
pkgs <- c(
  "Seurat",
  "Matrix",
  "ggplot2",
  "dplyr",
  "tibble",
  "patchwork",
  "Rfast2",
  "STew",
  "BiocManager"
)

to_install <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
if (length(to_install) > 0) {
  install.packages(to_install, repos = "https://cloud.r-project.org")
}

# Load
lapply(pkgs, library, character.only = TRUE)
```

# load in mouse data
```{r load-mouse-data}
mouse_seurat <- readRDS(params$mouse_rds_path)
mouse_seurat
```

# identify SVGs using Seurat
```{r find-mouse-svgs}
# coords (cells x 2)
spatial_loc <- as.matrix(mouse_seurat@meta.data[colnames(mouse_seurat), c("imagecol","imagerow"), drop=FALSE])
storage.mode(spatial_loc) <- "numeric"
colnames(spatial_loc) <- c("x","y")

# SCT expression (genes x cells - pearson residuals)
DefaultAssay(mouse_seurat) <- "SCT"
expr_sct <- GetAssayData(mouse_seurat, assay = "SCT", layer = "scale.data")

# can only use HVGs to speed up
#hvg <- as.character(VariableFeatures(mouse_seurat))
#expr_sct <- expr_sct[hvg, , drop = FALSE]

# run Moran's I SVG
svg_df <- FindSpatiallyVariableFeatures(
  object = expr_sct,
  spatial.location = spatial_loc,
  selection.method = "moransi"
)

# svg_df is the data.frame returned by FindSpatiallyVariableFeatures(...)
# inspect output
names(svg_df)
str(svg_df)

# get score columne
score_col <- intersect(
  c("moransi", "MoranI", "moran.i", "I", "observed", "statistic"),
  names(svg_df)
)[1]

if (is.na(score_col)) {
  stop("Couldn't find a Moran's I score column. Check names(svg_df).")
}

# score -> numeric vector (handles list/df columns)
score <- svg_df[[score_col]]
if (is.data.frame(score)) score <- score[[1]]
score <- as.numeric(score)

# order genes by score (high to low)
svg_genes <- rownames(svg_df)[order(score, decreasing = TRUE)]
head(svg_genes, 20)

# store
mouse_seurat@misc$svg_sct_moransi_table <- svg_df
mouse_seurat@misc$svg_sct_moransi_genes <- svg_genes
```

# store SVGs in a cell by location matrix
```{r mouse-svg-matrix}
mouse_svg_matrix <- GetAssayData(mouse_seurat, assay = "SCT", layer = "data")[mouse_seurat@misc$svg_sct_moransi_genes, ]
mouse_svg_matrix[1:5, 1:5]
head(rownames(mouse_svg_matrix), 20)
```
# save mouse SVG matrix
```{r save-mouse-svg-matrix}
saveRDS(mouse_svg_matrix, file = "/Users/emilyekstrum/repos/zhangLab_Rotation/data/processed/seurat_mouse_svg_matrix.rds")
```


# identify mouse SVGs using STew - FIX ME
```{r stew-mouse-svgs}
exp_count_meta <-readRDS("/Users/emilyekstrum/Desktop/zhangLab/data/MouseBrain_Data/10x_mousebrain_exp_count_meta.rds")
cell_loc <- exp_count_meta[, c(1:2)] # spot by (x,y)
exp <- exp_count_meta[, 3:31056] # row = spot col = gene
exp_count <- t(exp) # gene by cell -> seurat input

head(exp_count)
```

# nnSVG function from STew
```{r}
#Only needs BioCParallel and BRISC

nnSVG <- function(input, spatial_coords = NULL, X = NULL, 
                  assay_name = "logcounts", 
                  n_neighbors = 10, order = "AMMD", 
                  n_threads = 1, BPPARAM = NULL, 
                  verbose = FALSE) {
  
  if (is(input, "SpatialExperiment")) {
    spe <- input
    stopifnot(assay_name %in% assayNames(spe))
    # check for rows or columns of all zero counts
    if ("counts" %in% assayNames(spe)) {
      if (sum(rowSums(counts(spe)) == 0) > 0 | sum(colSums(counts(spe)) == 0) > 0) {
        warning("Rows (genes) and/or columns (spots) containing all zero counts ", 
                "have been found. Please see examples in tutorial for code to ", 
                "filter out zeros and/or low-expressed genes to avoid errors.")
      }
    }
  }

  if (!is.null(X)) {
    stopifnot(nrow(X) == ncol(input))
  }

  if (is.null(BPPARAM)) {
    BPPARAM <- MulticoreParam(workers = n_threads)
  }

  # -----------------------
  # run BRISC for each gene
  # -----------------------

  if (is(input, "MulticoreParam")) {
    y <- assays(spe)[[assay_name]]
    coords <- spatialCoords(spe)
  } else {
    y <- input
    coords <- spatial_coords
    row_names <- rownames(input)
  }

  # scale coordinates proportionally
  range_all <- max(apply(coords, 2, function(col) diff(range(col))))
  coords <- apply(coords, 2, function(col) (col - min(col)) / range_all)

  # calculate ordering of coordinates
  order_brisc <- BRISC_order(coords, order = order, verbose = verbose)

  # calculate nearest neighbors
  nn_brisc <- BRISC_neighbor(coords, n.neighbors = n_neighbors, n_omp = 1, 
                             search.type = "tree", ordering = order_brisc, 
                             verbose = verbose)
  
  # run BRISC using parallelization
  ix <- seq_len(nrow(y))
  out_brisc <- bplapply(ix, function(i) {
    # fit model (intercept-only model if x is NULL)
    y_i <- y[i, ]
    suppressWarnings({
      runtime <- system.time({
        out_i <- BRISC_estimation(coords = coords, y = y_i, x = X, 
                                  cov.model = "exponential", 
                                  ordering = order_brisc, neighbor = nn_brisc, 
                                  verbose = verbose)
      })
    })
    res_i <- c(
      out_i$Theta,
      loglik = out_i$log_likelihood,
      runtime = runtime[["elapsed"]]
    )
    res_i
  }, BPPARAM = BPPARAM)

  # collapse output list into matrix
  mat_brisc <- do.call("rbind", out_brisc)

  # --------------------
  # calculate statistics
  # --------------------

  lc <- input
  # mean logcounts
  mat_brisc <- cbind(
    mat_brisc,
    mean = rowMeans(lc)
  )
  # variance of logcounts
  mat_brisc <- cbind(
    mat_brisc,
    var = rowVars(as.matrix(lc))
  )
  # spatial coefficient of variation
  mat_brisc <- cbind(
    mat_brisc,
    spcov = sqrt(mat_brisc[, "sigma.sq"]) / mat_brisc[, "mean"]
  )

  # proportion of spatial variance out of total variance
  mat_brisc <- cbind(
    mat_brisc,
    prop_sv = mat_brisc[, "sigma.sq"] / (mat_brisc[, "sigma.sq"] + mat_brisc[, "tau.sq"])
  )

  # ------------------------------------------
  # likelihood ratio (LR) statistics and tests
  # ------------------------------------------

  if (is(input, "SpatialExperiment")) {
    nrows <- nrow(spe)
    ncols <- ncol(spe)
  } else {
    nrows <- nrow(input)
    ncols <- ncol(input)
  }
  
  # calculate log likelihoods for nonspatial models
  
  loglik_lm <- vapply(seq_len(nrows), function(i) {
    y_i <- y[i, ]
    if (is.null(X)) {
      X <- rep(1, ncols)
    }
    # model formula without intercept to enable weighted model
    as.numeric(logLik(lm(y_i ~ X - 1)))
  }, numeric(1))
  
  mat_brisc <- cbind(
    mat_brisc, 
    loglik_lm = loglik_lm
  )
  
  # calculate LR statistics and tests (Wilks' theorem, asymptotic chi-square
  # with 2 degrees of freedom)
  
  LR_stat <- -2 * (mat_brisc[, "loglik_lm"] - mat_brisc[, "loglik"])
  
  pval <- 1 - pchisq(LR_stat, df = 2)
  padj <- p.adjust(pval, method = "BH")
  
  # rank SVGs according to LR statistics
  LR_rank <- rank(-1 * LR_stat)
  
  mat_brisc <- cbind(
    mat_brisc, 
    LR_stat = LR_stat, 
    rank = LR_rank, 
    pval = pval, 
    padj = padj
  )

  # --------------
  # return outputs
  # --------------

  if (is(input, "SpatialExperiment")) {
    # return in rowData of spe object
    stopifnot(nrow(spe) == nrow(mat_brisc))
    rowData(spe) <- cbind(rowData(spe), mat_brisc)
    spe
  } else {
    # return as numeric matrix
    stopifnot(nrow(input) == nrow(mat_brisc))
    rownames(mat_brisc) <- row_names
    mat_brisc
  }
}
```

```{r stew-mouse-svgs-run}
#BiocManager::install("BiocParallel")
#BiocManager::install("BRISC")

library(BiocParallel)
library(BRISC)

exp_count <- t(exp)
start_time <- Sys.time()
svgs <- nnSVG(input = exp, spatial_coords = cell_loc, n_threads = 3)
end_time <- Sys.time()
time_nnsvg <- end_time - start_time
time_nnsvg
```

```{r}
dim(GetAssayData(mouse_seurat, assay="RNA", layer="data"))
dim(GetAssayData(mouse_seurat, assay="RNA", layer="counts"))


```


```{r}
library(Seurat)
library(Matrix)
library(BiocParallel)
library(BRISC)

bp <- SerialParam()  # reminder: avoid multicore until stable

# 1) Expression matrix (genes x cells). Use data if available, else counts.
X <- GetAssayData(mouse_seurat, assay = "RNA", layer = "data")
if (is.null(X) || nrow(X) == 0 || ncol(X) == 0) {
  X <- GetAssayData(mouse_seurat, assay = "RNA", layer = "counts")
}

# 2) Coordinates: must have rownames that are cell barcodes
coords <- mouse_seurat@meta.data[, c("imagecol", "imagerow"), drop = FALSE]
stopifnot(!is.null(rownames(coords)))

# 3) Align cells (this will now work)
common_cells <- intersect(colnames(X), rownames(coords))
stopifnot(length(common_cells) > 0)

X <- X[, common_cells, drop = FALSE]
coords <- as.matrix(coords[common_cells, , drop = FALSE])

# 4) Reduce genes to prevent aborts (pick HVGs that actually exist in X)
# If VariableFeatures exists but doesn't match, intersect fixes it.
genes_use <- VariableFeatures(mouse_seurat)
genes_use <- intersect(genes_use, rownames(X))
if (length(genes_use) < 200) {
  # fallback: pick top variable genes from X directly (fast + robust)
  gene_vars <- Matrix::rowMeans(X^2) - (Matrix::rowMeans(X))^2
  genes_use <- names(sort(gene_vars, decreasing = TRUE))[1:min(3000, length(gene_vars))]
}
X <- X[genes_use, , drop = FALSE]

# 5) Run serially
svgs <- nnSVG(input = X, spatial_coords = coords, BPPARAM = bp)


```

```{r}
head(rownames(GetAssayData(mouse_seurat, assay="RNA", layer="counts")))
head(colnames(GetAssayData(mouse_seurat, assay="RNA", layer="counts")))
head(rownames(mouse_seurat@meta.data))

```



#------------- human data ----------------#


# load in human data
```{r load-human-data}
human_seurat <- readRDS(params$human_rds_path)
human_seurat
```


# identify SVGs using Seurat
```{r find-human-svgs}
# coords (cells x 2)
spatial_loc <- as.matrix(human_seurat@meta.data[colnames(human_seurat), c("imagecol","imagerow"), drop=FALSE])
storage.mode(spatial_loc) <- "numeric"
colnames(spatial_loc) <- c("x","y")

# SCT expression (genes x cells - pearson residuals)
DefaultAssay(human_seurat) <- "SCT"
expr_sct <- GetAssayData(human_seurat, assay = "SCT", layer = "scale.data")

# again - only restrict to HVGs
#hvg <- as.character(VariableFeatures(human_seurat))
#expr_sct <- expr_sct[hvg, , drop = FALSE]

# run Moran's I SVG
svg_df <- FindSpatiallyVariableFeatures(
  object = expr_sct,
  spatial.location = spatial_loc,
  selection.method = "moransi"
)

# svg_df is the data.frame returned by FindSpatiallyVariableFeatures(...)
# inspect output
names(svg_df)
str(svg_df)

# get score column
score_col <- intersect(
  c("moransi", "MoranI", "moran.i", "I", "observed", "statistic"),
  names(svg_df)
)[1]

if (is.na(score_col)) {
  stop("Couldn't find a Moran's I score column. Check names(svg_df).")
}

# score -> numeric vector (handles list/df columns)
score <- svg_df[[score_col]]
if (is.data.frame(score)) score <- score[[1]]
score <- as.numeric(score)

#order genes by score (high to low)
svg_genes <- rownames(svg_df)[order(score, decreasing = TRUE)]
head(svg_genes, 20)

# store
human_seurat@misc$svg_sct_moransi_table <- svg_df
human_seurat@misc$svg_sct_moransi_genes <- svg_genes
```

# store SVGs in a cell by location matrix
```{r human-svg-matrix}
human_svg_matrix <- GetAssayData(human_seurat, assay = "SCT", layer = "data")[human_seurat@misc$svg_sct_moransi_genes, ]
human_svg_matrix[1:5, 1:5]
head(rownames(human_svg_matrix), 20)
```

# save mouse SVG matrix
```{r save-human-svg-matrix}
saveRDS(human_svg_matrix, file = "/Users/emilyekstrum/repos/zhangLab_Rotation/data/processed/seurat_human_svg_matrix.rds")
```

